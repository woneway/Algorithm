# kmp算法

## 什么是KMP算法？
KMP算法是模式匹配的一种改进算法，是D.E.Knuth、V.R.Pratt和J.H.Morris同时发现的。

此算法可以在O(m+n)的时间数量级上完成串的模式匹配操作。当失配时，不需要回溯i指针，而是利用已经得到的部分匹配结果将模式串向右滑动一定距离后继续比较。

举个例子
- 主串 S = a b a b c d e f a c
- 模式串 P = a b a b d
```text
        i
a b a b c d e f a c
        j
a b a b d
```
当我们比较到S(i) = c ,P(j)=d时，显然c ≠ d,按照普通的模式匹配算法，则应该将i回溯到b的位置，而j回溯到0，然后继续比较，即
```text
  i      
a b a b c d e f a c
  j
  a b a b d
```
显然b和a是不相等的，没有比较的必要，而kmp算法，帮我们解决了这个问题，并且避免了i指针的回溯，它将j向右滑动两个位置，指向第三个元素a，然后继续比较i和j位置的元素，即
```text
        i
a b a b c d e f a c
        j
    a b a b d
```

## KMP算法原理
从上面的分析，我们可以知道，kmp算法进行模式匹配，我们只需要知道当元素失配时(即Si!=Pj)，需要将模式串向右移动多少个位置。也就是说，当主串和模式串失配时，主串的第i个元素应该与模式串中的第几个元素比较。

那么假设第k(0<k<j)个元素与主串中的第i个元素继续比较，则有：
```text
p(0)p(1)...p(k-1) = S(i-k)S(i-k+1)..S(i-1) - （式一）
```
又因为Si之前的j个元素和Pj之前的j个元素时相等的，所以有：
```text
p(0)p(1)...p(j-1) = S(i-j)S(i-j+1)...S(i-1) - （式二）
```
由此推出下面的等式：
```text
p(0)p(1)...p(k-1) = p(j-k)p(j-k+1)...p(j-1) - （式三）
```
我们将这个过程画出来：
```text
S(0) S(1) ... S(i-j)  S(i-j+1)  ... ... S(i-1) S(i) 
              P(0)    P(1)      ... ... P(j-1) P(j)
S(i) ≠ P(j) 
S(0) S(1) ... S(i-j)  S(i-j+1)  S(i-k) ... ... S(i-1) S(i) 
                                P(0)   ... ... P(k-1) P(k)
```
由此我们可以看出，当S(i) ≠ P(j)时，我们只需要令j = k,让S(i) 和 P(j=k)继续比较即可。

## 如何推出k的值？
求k的值，也就是如果求出模式串的next数组，next数组的含义就是模式串第j个元素失配时，向右滑动到第几个元素继续进行匹配。

根据式三我们可以看出，求k的值，也就是求下一个继续比较的元素位置，与主串没有关系，仅仅与模式串本身相关。

式三的等式左边是0到j-1串的前缀，等式右边是0到j-1串的后缀，而k也就是j下一步移动到的元素的位置。

```text
          { -1  , j = 0
          |
next[j] = |Max{k|0<k<j,且p0...pk-1=pj-k...pj-1}
          | 
          { 0   ,其他情况
```
由此定义，模式串P的next函数值是：

|j|0 1 2 3 4|
|:----:|:------:|
|模式串 |a b a b d|
|next]|-1 0 0 1 2|

## 改进KMP算法
KMP算法已经解决了指针i的回溯问题，我们看下面这种情况
```
主串  a a a b a a a a b 
模式串  a a a a b
```
求得模式串P的next函数值为

|j|0 1 2 3 4|
|:--:|:------:|
|模式串|a a a a b|
|next|-1 0 1 2 3|

那么我们看下这种情况
```
      i
a a a b a a a a b
a a a a
      j
S(i)≠P(j),则j = next[j] = next[3]=2
也就是
      i
a a a b a a a a b
  a a a
      j
以此类推j = 1、0、-1    
```
但是我们看，其实模式串前面的四个值都是相等的，那么当j = 3的位置的元素与i=3位置的元素不相等时，一定有j = 0、1、2的位置的元素与i=3位置的元素不相等，那么也就不应该再去比较。
所以在求next函数的时候，如果说P[i]==P[j],那么令next[i] = next[j];
改进之后的next函数值


|j|0 1 2 3 4|
|:--:|:------:|
|模式串|a  a  a  a b|
|next|-1 -1 -1 -1 3|
